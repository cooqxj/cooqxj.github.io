---
layout: post
title:  "[WEB][Beginner] php7cmp4re"
date:   2025-12-02 24:04:29 +0900
categories: wargame dreamhack
---

직무 변경을 위해 이직 준비를 하다보니,
기술적인 갈증이 계속 생겨서 워게임을 시작했다.

웹 개발 경력과 보안 수업 때 몇 문제 풀어본 경험이 있어서
제일 쉬운 난이도의 웹 해킹 문제에 도전했다.

![Dreamhack-php7cmp4re 초기화면](/assets/wargame/dreamhack/images/php7cmp4re-01.png)

가상화면 접근 시 처음 표시되는 화면이다.
Flag 획득 조건은 올바른 Input값 삽입이었다.

{% highlight php %}
if ($_SERVER["REQUEST_METHOD"] == "POST") {
  $input_1 = $_POST["input1"] ? $_POST["input1"] : "";
  $input_2 = $_POST["input2"] ? $_POST["input2"] : "";
  sleep(1);

  if($input_1 != "" && $input_2 != ""){
    if(strlen($input_1) < 4){
      if($input_1 < "8" && $input_1 < "7.A" && $input_1 > "7.9"){
        if(strlen($input_2) < 3 && strlen($input_2) > 1){
          if($input_2 < 74 && $input_2 > "74"){
            echo "</br></br></br><pre>FLAG\n";
            echo $flag;
            echo "</pre>";
          } else echo "<br><br><br><h4>Good try.</h4>";
        } else echo "<br><br><br><h4>Good try.</h4><br>";
      } else echo "<br><br><br><h4>Try again.</h4><br>";
    } else echo "<br><br><br><h4>Try again.</h4><br>";
  } else{
    echo '<br><br><br><h4>Fill the input box.</h4>';
  }
} else echo "<br><br><br><h3>WHat??!</h3>";
{% endhighlight %}

해당 문제에서 제공된 파일 중 check.php 파일의 코드 일부분이다.
input1, input2의 입력값을 검증하는 조건 분기이다.

{% highlight php %}
if ($_SERVER["REQUEST_METHOD"] == "POST") {
  $input_1 = $_POST["input1"] ? $_POST["input1"] : "";
  $input_2 = $_POST["input2"] ? $_POST["input2"] : "";
  sleep(1);
  // input1, input2 입력값 검증
} else echo "<br><br><br><h3>WHat??!</h3>";
{% endhighlight %}

첫 번째 조건 분기는 HTTP REQUEST METHOD가 POST인지 여부를 확인하고 있었다.
제출 버튼이 아닌 URL을 통해 check.php 페이지에 접근하면 else에 있는 WHat??! 문구를 확인할 수 있다.

첫 번째 조건 분기를 만족할 경우 input1에 데이터 유무를 확인하여 데이터가 없을 경우 빈 문자열("")을 할당한다.

{% highlight php %}
if($input_1 != "" && $input_2 != ""){
  // input1, input2 입력값 검증
} else{
  echo '<br><br><br><h4>Fill the input box.</h4>';
}
{% endhighlight %}

두 번째 조건 분기는 input1 또는 input2 입력값이 빈 문자열("")인지를 확인한다.
input1/input2 중 하나라도 데이터를 입력하지 않았을 경우 Fill the input box. 문구를 출력한다.

{% highlight php %}
if(strlen($input_1) < 4){
  if($input_1 < "8" && $input_1 < "7.A" && $input_1 > "7.9"){
    // input2 입력값 검증
  } else echo "<br><br><br><h4>Try again.</h4><br>";
} else echo "<br><br><br><h4>Try again.</h4><br>";
{% endhighlight %}

세 번째와 네 번째 조건 분기는 input1에 대한 입력값 검증이다.
세 번째 조건을 통해 input1은 4자리 이상이 될 수 없다는 걸 알 수 있다.

네 번째 조건에선 "8"과 "7.A" 보다 작지만 "7.9" 보다 커야한다는 걸 알 수 있다.
정말 오래전에 독학했던 C언어에서 char 형식을 비교할 땐 아스키 코드값을 기준으로 비교했던 기억이 났다.

"8"보다 작으면서 "7.9"와 "7.A" 사이에 위치하기 위해서는,
input1이 "7."으로 시작하는 세 자리 문자열이란 걸 추측할 수 있다.

아스키 코드 표를 참고하여 9보다 크고 A보다 작은 문자 하나를 선택해 세 자리를 완성하면 된다.
나는 A보다 1 작은 "@"를 선택하여 input1에 "7.@"를 입력하였다.

{% highlight php %}
if(strlen($input_2) < 3 && strlen($input_2) > 1){
  if($input_2 < 74 && $input_2 > "74"){
    echo "</br></br></br><pre>FLAG\n";
    echo $flag;
    echo "</pre>";
  } else echo "<br><br><br><h4>Good try.</h4>";
} else echo "<br><br><br><h4>Good try.</h4><br>";
{% endhighlight %}

다섯 번째와 여섯 번째 조건 분기는 input2에 대한 입력값 검증이다.

input1 입력값 검증까지 성공하였다면,
input2 입력값이 틀렸을 때 Good try 문구를 확인할 수 있다.

다섯 번째 조건에서 input2가 2자리임을 알 수 있다.

여섯 번째 조건에선 input2 값이 정수 74보다 작지만 문자열 "74"보다 크다는 것을 알 수 있다.

"74"를 10진수로 치환하면 55 52가 된다.
74를 아스키 코드로 치환하면 "J"가 된다.
input2는 아스키 코드 표에서 "7"과 "J" 사이 문자로 시작하는 두 자리 값이다.

다만 input2가 "88"과 같이 아스키 코드로 치환하지 않아도 숫자 형태로 변환이 가능할 경우,
"88" < 74 는 88 < 74 가 되어 입력값 검증에 실패하기 때문에 문자를 포함하여야 한다.

![Dreamhack-php7cmp4re input2 오답](/assets/wargame/dreamhack/images/php7cmp4re-02.png)
![Dreamhack-php7cmp4re Good try](/assets/wargame/dreamhack/images/php7cmp4re-03.png)

어려운 조건은 아니지만 헷갈리는 요소가 있어서 몇 번 오답을 냈었다.
나의 경우 위 조건들을 만족하는 값으로 "AA"를 정답으로 제출하였다.

![Dreamhack-php7cmp4re 최종 답안](/assets/wargame/dreamhack/images/php7cmp4re-04.png)
![Dreamhack-php7cmp4re 문제 해결](/assets/wargame/dreamhack/images/php7cmp4re-05.png)

처음으로 도전한 워게임 문제는 풀이를 보고 해결 할 수 있었다.
문제 접근 방식에 대한 문제였기 때문에 처음 실패하고 풀이를 찾아보길 잘 했다는 생각이 든다.

짧게나마 회고를 하자면,
문제에 PHP7.4라는 버전이 명시 되어있어서 관련 취약점을 먼저 찾아보았다.

처음엔 SQL Injection이라고 생각했는데,
2시간 동안 개발자 도구를 까뒤집고 Burp Suite로 이것저것 시도해봐도 실마리 조차 찾을 수 없었다.

다른 사람의 풀이를 찾아보니 문제 파일로 제공되는 PHP 코드 파일의 정적 분석을 통해 값을 도출해내야 했다.
PHP 버전 정보는 PHP 버전에 따라 문자열 비교의 처리 결과가 달라지기 때문인 것 같다.

너무 공격자 관점으로만 Flag를 찾아내려고 했던게 문제 요인이 되었다.

다음 문제 부터는 보안 관점에서 정적/동적 분석 모두 활용하여 유연한 접근이 필요할 것 같다.